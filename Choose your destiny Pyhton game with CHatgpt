# Import the necessary libraries and modules
# we will use a vectorized database tht can store and retrieve data in a fast and efficient way we will use datatstax

# Cassandra library to connect to the database
from cassandra.cluster import Cluster
# Cassandra module to provide username and password for connection
from cassandra.auth import PlainTextAuthProvider
# will allow us to setup piplines to deal with llm, large lamguage models and databases
# Langchain libraries for handling large language models and databases
from langchain.memory import CassandraChatMessageHistory, ConversationBufferMemory
from langchain.llms import OpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
# json library to handle JSON files
import json

# Define the secure connect bundle, which contains the information needed to connect to the database

cloud_config = {
    'secure_connect_bundle': 'secure-connect-game-adventure.zip'
}

# Load the token file, which contains the client id and secret needed to connect to the database
with open("game_adventure-token.json") as f:
    secrets = json.load(f)

# Extract the client id and secret from the token file
CLIENT_ID = secrets["clientId"]
CLIENT_SECRET = secrets["secret"]
# Define the keyspace (database) to be used in Cassandra
ASTRA_DB_KEYSPACE = "database"
# Define the API key for OpenAI
OPENAI_API_KEY = "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"

# Set up the authentication provider with the client id and secret
auth_provider = PlainTextAuthProvider(CLIENT_ID, CLIENT_SECRET)
# Set up the connection to the Cassandra cluster
cluster = Cluster(cloud=cloud_config, auth_provider=auth_provider)
# Establish a session with the Cassandra cluster
session = cluster.connect()

# Set up the chat message history, which will store messages in the Cassandra database
message_history = CassandraChatMessageHistory(
    session_id="anything",
    session=session,
    keyspace=ASTRA_DB_KEYSPACE,
    ttl_seconds=3600  # Messages will be automatically deleted after 3600 seconds (60 minutes)
)

# Clear any existing messages from the chat history
message_history.clear()
# Set up the conversation buffer memory, which will keep track of the chat history
cass_buff_memory = ConversationBufferMemory(
    memory_key="chat_history",
    chat_memory=message_history
)

# Define the template for the AI prompts. This provides context and rules for the AI.
template = """  
You are now the guide of a mystical journey in the Whispering Woods. 
A traveler named Elara seeks the lost Gem of Serenity. 
You must navigate her through challenges, choices, and consequences, 
dynamically adapting the tale based on the traveler's decisions. 

Here are some rules to follow:
1. Start by asking the player to choose some kind of weapons that will be used later in the game
2. Have a few paths that lead to success
3. Have some paths that lead to death. If the user dies generate a response that explains the death and ends in the text: "The End.", I will search for this text to end the game

Here is the chat history, use this to understand what to say next: {chat_history}
Human: {human_input}
AI:"""

# Set up the prompt template with the defined template and input variables
prompt = PromptTemplate(
    input_variables=["chat_history", "human_input"],
    template=template
)

# Initialize the OpenAI model with the API key
llm = OpenAI(openai_api_key=OPENAI_API_KEY)
# Set up the language model chain, which combines the OpenAI model, the chat prompt, and the conversation buffer memory
llm_chain = LLMChain(
    llm=llm,
    prompt=prompt,
    memory=cass_buff_memory
)
# Set the initial choice to "start"
choice = "start"
# Enter a while loop, which will continue until the response contains "The End."
while True:
    # Predict a response based on the user's choice and the chat history
    response = llm_chain.predict(human_input=choice)
    # Strip the response to remove any trailing or leading whitespace
    print(response.strip())
    # If the response contains "The End.", break the loop
    if "The End." in response:
        break
    # Ask the user for their next choice
    choice = input("Your reply: ")


### Description of the program:"
# This program is an interactive AI-based text game, where the AI guides a user through a story based on the user's inputs. The AI's responses are generated by OpenAI's GPT-3 model, and the chat history is stored using DataStax's Cassandra database. Here's how it works:

# 1. The program first establishes a connection to a Cassandra database using authentication details provided in a secure connect bundle and a JSON token file. The secure connect bundle contains connection details such as the database's IP address and port, while the JSON token file contains a client ID and secret for authentication.

# 2. Once the connection to the Cassandra database is established, the program sets up a `CassandraChatMessageHistory` object. This object is responsible for storing and retrieving chat messages from the database. Messages are associated with a session ID and are set to be automatically deleted from the database after a certain period of time (in this case, 60 minutes).

# 3. The program then sets up a `ConversationBufferMemory` object, which uses the `CassandraChatMessageHistory` object to keep track of the chat history. This allows the AI to refer back to previous messages when generating a response.

# 4. The AI's responses are generated based on a template provided to the `PromptTemplate` object. This template contains a context for the AI (in this case, the AI is guiding a journey through the Whispering Woods), as well as rules for the AI to follow (such as starting by asking the player to choose a weapon, and including paths that lead to success and death).

# 5. The program then initializes the OpenAI GPT-3 model and sets up a `LLMChain` object, which is responsible for generating the AI's responses. The `LLMChain` object uses the `ConversationBufferMemory` object to access the chat history, and the `PromptTemplate` object to generate a response based on the user's input.

# 6. The game starts with an initial user input of "start". The program enters a while loop, where it uses the `LLMChain` object to generate an AI response based on the user's input, and then prints this response. The user is then asked to provide their next choice.

# 7. This process repeats until the AI generates a response containing "The End.", indicating that the game has ended. At this point, the while loop is exited and the program finishes."
